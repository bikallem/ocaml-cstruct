<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cstruct_cap (cstruct.Cstruct_cap)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0-334-ga942491"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../index.html">cstruct</a> &#x00BB; Cstruct_cap</nav><header><h1>Module <code>Cstruct_cap</code></h1></header><nav class="toc"><ul><li><a href="#helpers-to-parse-with-capabilities.">Helpers to parse with capabilities.</a></li></ul></nav><div class="content"><div><div class="spec type" id="type-rd" class="anchored"><a href="#type-rd" class="anchor"></a><code><span class="keyword">type</span> <span>'a rd</span> = &lt; rd : unit; .. &gt; <span class="keyword">as</span> 'a</code></div><div><p>Type of read capability.</p></div></div><div><div class="spec type" id="type-wr" class="anchored"><a href="#type-wr" class="anchor"></a><code><span class="keyword">type</span> <span>'a wr</span> = &lt; wr : unit; .. &gt; <span class="keyword">as</span> 'a</code></div><div><p>Type of write capability.</p></div></div><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></div><div><p>Type of cstruct with capabilities <code>'a</code>.</p></div></div><div><div class="spec type" id="type-buffer" class="anchored"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer = <span><span>(char, <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span></code></div><div><p>Type of buffer. A <a href="index.html#type-t"><code>t</code></a> is composed of an underlying buffer.</p></div></div><div><div class="spec type" id="type-rdwr" class="anchored"><a href="#type-rdwr" class="anchor"></a><code><span class="keyword">type</span> rdwr = &lt; rd : unit; wr : unit; &gt;</code></div><div><p>Type of read-and-capability.</p></div></div><div><div class="spec type" id="type-ro" class="anchored"><a href="#type-ro" class="anchor"></a><code><span class="keyword">type</span> ro = &lt; rd : unit; &gt;</code></div><div><p>Type of read-only capability.</p></div></div><div><div class="spec type" id="type-wo" class="anchored"><a href="#type-wo" class="anchor"></a><code><span class="keyword">type</span> wo = &lt; wr : unit; &gt;</code></div><div><p>Type of write-only capability.</p></div></div><div><div class="spec type" id="type-uint8" class="anchored"><a href="#type-uint8" class="anchor"></a><code><span class="keyword">type</span> uint8 = int</code></div><div><p>8-bit unsigned integer.</p></div></div><div><div class="spec type" id="type-uint16" class="anchored"><a href="#type-uint16" class="anchor"></a><code><span class="keyword">type</span> uint16 = int</code></div><div><p>16-bit unsigned integer.</p></div></div><div><div class="spec type" id="type-uint32" class="anchored"><a href="#type-uint32" class="anchor"></a><code><span class="keyword">type</span> uint32 = int32</code></div><div><p>32-bit unsigned integer.</p></div></div><div><div class="spec type" id="type-uint64" class="anchored"><a href="#type-uint64" class="anchor"></a><code><span class="keyword">type</span> uint64 = int64</code></div><div><p>64-bit unsigned integer.</p></div></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>create len</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of size <code>len</code>. with an offset of 0, filled with zero bytes.</p></div></div><div><div class="spec value" id="val-create_unsafe" class="anchored"><a href="#val-create_unsafe" class="anchor"></a><code><span class="keyword">val</span> create_unsafe : int <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>create_unsafe len</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of size <code>len</code> with an offset of 0.</p><p>Note that the returned cstruct will contain arbitrary data, likely including the contents of previously-deallocated cstructs.</p><p>Beware!</p><p>Forgetting to replace this data could cause your application to leak sensitive information.</p></div></div><div><div class="spec value" id="val-ro" class="anchored"><a href="#val-ro" class="anchor"></a><code><span class="keyword">val</span> ro : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-ro">ro</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>ro t</code> has <code>t</code> to be read-only then.</p></div></div><div><div class="spec value" id="val-wo" class="anchored"><a href="#val-wo" class="anchor"></a><code><span class="keyword">val</span> wo : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-wo">wo</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>wo t</code> has <code>t</code> to be write-only then.</p></div></div><div><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>of_string ~off ~len s</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of <code>s</code> sliced on <code>off</code> (default is <code>0</code>) and of <code>len</code> (default is <code>String.length s</code>) length.</p></div></div><div class="spec value" id="val-of_bytes" class="anchored"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><div class="spec value" id="val-of_hex" class="anchored"><a href="#val-of_hex" class="anchor"></a><code><span class="keyword">val</span> of_hex : string <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>of_bytes ~off ~len x</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of <code>x</code> sliced on <code>off</code> (default is <code>0</code>) and of <code>len</code> (default is <code>Bytes.length x</code>) length.</p></div></div><div><div class="spec value" id="val-to_bigarray" class="anchored"><a href="#val-to_bigarray" class="anchor"></a><code><span class="keyword">val</span> to_bigarray : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a></code></div><div><p><code>to_bigarray t</code> converts <a href="index.html#type-t"><code>t</code></a> into a <a href="index.html#type-buffer"><code>buffer</code></a> Bigarray, using the Bigarray slicing to allocate a fresh <i>proxy</i> Bigarray that preserves sharing of the underlying buffer.</p><p>In other words:</p><pre><code>let t = Cstruct_cap.create 10 in
let b = Cstruct_cap.to_bigarray t in
Bigarray.Array1.set b 0 '\x42' ;
assert (Cstruct_cap.get_char t 0 = '\x42')</code></pre></div></div><div><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>equal a b</code> is <code>true</code> iff <code>a</code> and <code>b</code> correspond to the same sequence of bytes (it uses <code>memcmp</code> internally). Both need at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p></div></div><div><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></div><div><p><code>compare a b</code> gives an unspecified total ordering over <a href="index.html#type-t"><code>t</code></a>. Both need at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p></div></div><div><div class="spec value" id="val-check_alignment" class="anchored"><a href="#val-check_alignment" class="anchor"></a><code><span class="keyword">val</span> check_alignment : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></div><div><p><code>check_alignment t alignment</code> is <code>true</code> if the first byte stored within <code>t</code> is at a memory address where <code>address mod alignment = 0</code>, <code>false</code> otherwise. The <code>mod</code> used has the C/OCaml semantic (which differs from Python). Typical uses are to check a buffer is aligned to a page or disk sector boundary. <code>t</code> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>alignment</code> is not a positive integer.</p></dd></dl></div></div><div><div class="spec value" id="val-get_char" class="anchored"><a href="#val-get_char" class="anchor"></a><code><span class="keyword">val</span> get_char : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></div><div><p><code>get_char t off</code> returns the character contained in <code>t</code> at offset <code>off</code>. <code>t</code> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></div></div><div><div class="spec value" id="val-get_uint8" class="anchored"><a href="#val-get_uint8" class="anchor"></a><code><span class="keyword">val</span> get_uint8 : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-uint8">uint8</a></code></div><div><p><code>get_uint8 t off</code> returns the byte contained in <code>t</code> at offset <code>off</code>. <code>t</code> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></div></div><div><div class="spec value" id="val-set_char" class="anchored"><a href="#val-set_char" class="anchor"></a><code><span class="keyword">val</span> set_char : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></div><div><p><code>set_char t off c</code> sets the character contained in <code>t</code> at offset <code>off</code> to character <code>c</code>. <code>t</code> needs at least write capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></div></div><div><div class="spec value" id="val-set_uint8" class="anchored"><a href="#val-set_uint8" class="anchor"></a><code><span class="keyword">val</span> set_uint8 : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-uint8">uint8</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>set_uint8 t off x</code> sets the byte contained in <code>t</code> at offset <code>off</code> to byte <code>x</code>. <code>t</code> needs at least write capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></div></div><div><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>sub t ~off ~len</code> returns a fresh <a href="index.html#type-t"><code>t</code></a> with the shared underlying buffer of <code>t</code> sliced on <code>off</code> and of <code>len</code> length. New <a href="index.html#type-t"><code>t</code></a> shares same capabilities than <code>t</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length.</p></dd></dl></div></div><div><div class="spec value" id="val-shift" class="anchored"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val</span> shift : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>shift t len</code> returns a fresh <a href="index.html#type-t"><code>t</code></a> with the shared underlying buffer of <code>t</code> shifted to <code>len</code> bytes. New <a href="index.html#type-t"><code>t</code></a> shares same capabilities than <code>t</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length.</p></dd></dl></div></div><div><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></div><div><p><code>to_string ~off ~len t</code> is the string representation of the segment of <code>t</code> starting at <code>off</code> (default is <code>0</code>) of size <code>len</code> (default is <code>length t</code>). <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>off</code> and <code>len</code> does not designate a valid segment of <code>t</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-to_bytes" class="anchored"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bytes</code></div><div><p><code>to_bytes ~off ~len t</code> is the bytes representation of the segment of <code>t</code> starting at <code>off</code> (default is <code>0</code>) of size <code>len</code> (default is <code>length t</code>). <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>off</code> and <code>len</code> do not designate a valid segment of <code>t</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>blit src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to <code>dst</code>, starting at index <code>dst_off</code>. It works correctly even if <code>src</code> and <code>dst</code> have the same underlying <a href="index.html#type-buffer"><code>buffer</code></a>, and the <code>src</code> and <code>dst</code> intervals overlap. This function uses <code>memmove</code> internally.</p><p><code>src</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. <code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>. Both don't share capabilities.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid segment of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_from_string" class="anchored"><a href="#val-blit_from_string" class="anchor"></a><code><span class="keyword">val</span> blit_from_string : string <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_from_string src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to <code>dst</code>, starting at index <code>dst_off</code>. This function uses <code>memcpy</code> internally.</p><p><code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid sub-string of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_from_bytes" class="anchored"><a href="#val-blit_from_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_from_bytes : bytes <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_from_bytes src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to <code>dst</code>, starting at index <code>dst_off</code>. This uses <code>memcpy</code> internally.</p><p><code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid sub-sequence of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do no designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_to_bytes" class="anchored"><a href="#val-blit_to_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_to_bytes : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_to_bytes src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to sequences <code>dst</code>, starting at index <code>dst_off</code>. <code>blit_to_bytes</code> uses <code>memcpy</code> internally.</p><p><code>src</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid segment of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid sub-seuqnce of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-memset" class="anchored"><a href="#val-memset" class="anchor"></a><code><span class="keyword">val</span> memset : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>memset t x</code> sets all bytes of <code>t</code> to <code>x land 0xff</code>. <code>t</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>.</p></div></div><div><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></div><div><p><code>length t</code> return length of <code>t</code>. Note that this length is potentially smaller than the actual size of the underlying buffer, as the <a href="index.html#val-sub"><code>sub</code></a> function can construct a smaller view. <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p></div></div><div><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>?&#8288;start:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>split ~start t len</code> is a tuple containing <a href="index.html#type-t"><code>t</code></a>s extracted from <code>t</code> at offset <code>start</code> (default is <code>0</code>) of length <code>len</code> as first element, and the rest of <code>t</code> as second element.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sart</code> exceeds the <code>t</code> length, or if there is a bounds violation of <code>t</code> via <code>len + start</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span class="xref-unresolved">Stdlib</span>.Format.formatter <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></div><div><p>Pretty-printer of <a href="index.html#type-t"><code>t</code></a>. <a href="index.html#type-t"><code>t</code></a> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p></div></div><div class="spec module" id="module-BE" class="anchored"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-LE" class="anchored"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-lenv" class="anchored"><a href="#val-lenv" class="anchor"></a><code><span class="keyword">val</span> lenv : <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> int</code></div><div><p><code>lenv vs</code> is the combined length of all <a href="index.html#type-t"><code>t</code></a> in <code>vs</code>. Each <a href="index.html#type-t"><code>t</code></a> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if computing the sum overflows.</p></dd></dl></div></div><div><div class="spec value" id="val-copyv" class="anchored"><a href="#val-copyv" class="anchor"></a><code><span class="keyword">val</span> copyv : <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> string</code></div><div><p><code>copy vs</code> is the string representation of the concatenation of all <a href="index.html#type-t"><code>t</code></a> in <code>vss</code>. Each <a href="index.html#type-t"><code>t</code></a> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the length of the result would exceed <code>Sys</code>.max_string_length.</p></dd></dl></div></div><div><div class="spec value" id="val-fillv" class="anchored"><a href="#val-fillv" class="anchor"></a><code><span class="keyword">val</span> fillv : <span>src:<span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span></span> <span>&#45;&gt;</span> <span>dst:<span><span><span class="type-var">'b</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> int * <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span></code></div><div><p><code>fillv ~src ~dst</code> copies from <code>src</code> to <code>dst</code> until <code>src</code> is exhausted or <code>dst</code> is full. It returns the number of bytes copied and the remaining data from <code>src</code>, if any. This is useful if you want to <i>bufferize</i> data into fixed-sized chunks. Each <a href="index.html#type-t"><code>t</code></a> of <code>src</code> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. <code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>. Each <a href="index.html#type-t"><code>t</code></a> of <code>src</code> and dst don't share capabilities.</p></div></div><div><div class="spec type" id="type-iter" class="anchored"><a href="#type-iter" class="anchor"></a><code><span class="keyword">type</span> <span>'a iter</span> = unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div><p>Type of iterator.</p></div></div><div><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int option</span>)</span> <span>&#45;&gt;</span> <span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'v</span>)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-iter">iter</a></span></code></div><div><p><code>iter lenf of_cstruct t</code> is an iterator over <code>t</code> that returns elements of size <code>lenf t</code> and type <code>of_cstruct t</code>. <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a> and <code>iter</code> keeps capabilities of <code>t</code> on <code>of_cstruct</code>.</p></div></div><div><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'x</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'x</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></div><div><p><code>fold f iter acc</code> is <code>(f iterN accN ... (f iter acc)...)</code>.</p></div></div><div><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>append a b</code> create a fresh <a href="index.html#type-t"><code>t</code></a> which is the concatenation of <code>a</code> and <code>b</code>. <code>a</code> and <code>b</code> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. Resulted <a href="index.html#type-t"><code>t</code></a> has read-and-write capability.</p></div></div><div><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>concat vss</code> is the concatenation of all <a href="index.html#type-t"><code>t</code></a> in <code>vss</code>. Each <a href="index.html#type-t"><code>t</code></a> of <code>vss</code> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. <code>concat</code> always creates a fresh <a href="index.html#type-t"><code>t</code></a>.</p></div></div><div><div class="spec value" id="val-rev" class="anchored"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>rev t</code> is <code>t</code> in reverse order. The return value is a freshly allocated <a href="index.html#type-t"><code>t</code></a>, and <code>t</code> is not modified according <a href="index.html#type-rd"><code>rd</code></a> capability.</p></div></div><h3 id="helpers-to-parse-with-capabilities."><a href="#helpers-to-parse-with-capabilities." class="anchor"></a>Helpers to parse with capabilities.</h3><aside><p>As <code>Cstruct</code>, capabilities interface provides helpers functions to help the user to parse contents.</p></aside><div><div class="spec value" id="val-head" class="anchored"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>char option</span></code></div><div><p><code>head cs</code> is <code>Some (get cs h)</code> with <code>h = 0</code> if <code>rev = false</code> (default) or <code>h
   = length cs - 1</code> if <code>rev = true</code>. <code>None</code> is returned if <code>cs</code> is empty.</p></div></div><div><div class="spec value" id="val-tail" class="anchored"><a href="#val-tail" class="anchor"></a><code><span class="keyword">val</span> tail : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>tail cs</code> is <code>cs</code> without its first (<code>rev</code> is <code>false</code>, default) or last (<code>rev</code> is <code>true</code>) byte or <code>cs</code> is empty.</p></div></div><div><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_empty cs</code> is <code>length cs = 0</code>.</p></div></div><div><div class="spec value" id="val-is_prefix" class="anchored"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val</span> is_prefix : <span>affix:<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_prefix ~affix cs</code> is <code>true</code> iff <code>affix.[zidx] = cs.[zidx]</code> for all indices <code>zidx</code> of <code>affix</code>.</p></div></div><div><div class="spec value" id="val-is_suffix" class="anchored"><a href="#val-is_suffix" class="anchor"></a><code><span class="keyword">val</span> is_suffix : <span>affix:<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_suffix ~affix cs</code> is <code>true</code> iff <code>affix.[n - zidx] = cs.[m - zidx]</code> for all indices <code>zidx</code> of <code>affix</code> with <code>n = length affix - 1</code> and <code>m = length cs
   - 1</code>.</p></div></div><div><div class="spec value" id="val-is_infix" class="anchored"><a href="#val-is_infix" class="anchor"></a><code><span class="keyword">val</span> is_infix : <span>affix:<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_infix ~affix cs</code> is <code>true</code> iff there exists an index <code>z</code> in <code>cs</code> such that for all indices <code>zidx</code> of <code>affix</code> we have <code>affix.[zidx] = cs.[z +
   zidx]</code>.</p></div></div><div><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>for_all p cs</code> is <code>true</code> iff for all indices <code>zidx</code> of <code>cs</code>, <code>p cs.[zidx] =
   true</code>.</p></div></div><div><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>exists p cs</code> is <code>true</code> iff there exists an index <code>zidx</code> of <code>cs</code> with <code>p
   cs.[zidx] = true</code>.</p></div></div><div><div class="spec value" id="val-start" class="anchored"><a href="#val-start" class="anchor"></a><code><span class="keyword">val</span> start : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>start cs</code> is the empty sub-part at the start position of <code>cs</code>.</p></div></div><div><div class="spec value" id="val-stop" class="anchored"><a href="#val-stop" class="anchor"></a><code><span class="keyword">val</span> stop : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>stop cs</code> is the empty sub-part at the stop position of <code>cs</code>.</p></div></div><div><div class="spec value" id="val-trim" class="anchored"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : <span>?&#8288;drop:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>trim ~drop cs</code> is <code>cs</code> with prefix and suffix bytes satisfying <code>drop</code> in <code>cs</code> removed. <code>drop</code> defaults to <code>function ' ' | '\r' .. '\t' -&gt; true | _ -&gt;
   false</code>.</p></div></div><div><div class="spec value" id="val-span" class="anchored"><a href="#val-span" class="anchor"></a><code><span class="keyword">val</span> span : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;min:int</span> <span>&#45;&gt;</span> <span>?&#8288;max:int</span> <span>&#45;&gt;</span> <span>?&#8288;sat:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> * <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>span ~rev ~min ~max ~sat cs</code> is <code>(l, r)</code> where:</p><ul><li>if <code>rev</code> is <code>false</code> (default), <code>l</code> is at least <code>min</code> and at most <code>max</code> consecutive <code>sat</code> satisfying initial bytes of <code>cs</code> or <code>empty</code> if there are no such bytes. <code>r</code> are the remaining bytes of <code>cs</code>.</li><li>if <code>rev</code> is <code>true</code>, <code>r</code> is at least <code>min</code> and at most <code>max</code> consecutive <code>sat</code> satisfying final bytes of <code>cs</code> or <code>empty</code> if there are no such bytes. <code>l</code> are the remaining bytes of <code>cs</code>.</li></ul><p>If <code>max</code> is unspecified the span is unlimited. If <code>min</code> is unspecified it defaults to <code>0</code>. If <code>min &gt; max</code> the condition can't be satisfied and the left or right span, depending on <code>rev</code>, is always empty. <code>sat</code> defaults to <code>(fun _ -&gt; true)</code>.</p><p>The invariant <code>l ^ r = s</code> holds.</p><p>For instance, the <i>ABNF</i> expression:</p><pre>  time := 1*10DIGIT</pre><p>can be translated to:</p><pre><code>let (time, _) = span ~min:1 ~max:10 is_digit cs in</code></pre><dl><dt>raises Invalid_argument</dt><dd><p>if <code>max</code> or <code>min</code> is negative.</p></dd></dl></div></div><div><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;min:int</span> <span>&#45;&gt;</span> <span>?&#8288;max:int</span> <span>&#45;&gt;</span> <span>?&#8288;sat:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>take ~rev ~min ~max ~sat cs</code> is the matching span of <a href="index.html#val-span"><code>span</code></a> without the remaining one. In other words:</p><pre><code>(if rev then snd else fst) @@ span ~rev ~min ~max ~sat cs</code></pre></div></div><div><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;min:int</span> <span>&#45;&gt;</span> <span>?&#8288;max:int</span> <span>&#45;&gt;</span> <span>?&#8288;sat:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>drop ~rev ~min ~max ~sat cs</code> is the remaining span of <a href="index.html#val-span"><code>span</code></a> without the matching one. In other words:</p><pre><code>(if rev then fst else snd) @@ span ~rev ~min ~max ~sat cs</code></pre></div></div><div><div class="spec value" id="val-cut" class="anchored"><a href="#val-cut" class="anchor"></a><code><span class="keyword">val</span> cut : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>sep:<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> * <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span>)</span> option</span></code></div><div><p><code>cut ~sep cs</code> is either the pair <code>Some (l, r)</code> of the two (possibly empty) sub-buffers of <code>cs</code> that are delimited by the first match of the non empty separator string <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>cs</code>. Matching starts from the beginning of <code>cs</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>).</p><p>The invariant <code>l ^ sep ^ r = s</code> holds.</p><p>For instance, the <i>ABNF</i> expression:</p><pre>  field_name := *PRINT
  field_value := *ASCII
  field := field_name &quot;:&quot; field_value</pre><p>can be translated to:</p><pre><code>match cut ~sep:&quot;:&quot; value with
| Some (field_name, field_value) -&gt; ...
| None -&gt; invalid_arg &quot;invalid field&quot;</code></pre><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty buffer.</p></dd></dl></div></div><div><div class="spec value" id="val-cuts" class="anchored"><a href="#val-cuts" class="anchor"></a><code><span class="keyword">val</span> cuts : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;empty:bool</span> <span>&#45;&gt;</span> <span>sep:<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span></code></div><div><p><code>cuts ~sep cs</code> is the list of all sub-buffers of <code>cs</code> that are delimited by matches of the non empty separator <code>sep</code>. Empty sub-buffers are omitted in the list if <code>empty</code> is <code>false</code> (default to <code>true</code>).</p><p>Matching separators in <code>cs</code> starts from the beginning of <code>cs</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>). Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>cs</code>, the list <code>[cs]</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>concat ~sep (cuts ~empty:true ~sep cs) = cs</code></li><li><code>cuts ~empty:true ~sep cs &lt;&gt; []</code></li></ul><p>For instance, the <i>ABNF</i> expression:</p><pre>  arg := *(ASCII / &quot;,&quot;) ; any characters exclude &quot;,&quot;
  args := arg *(&quot;,&quot; arg)</pre><p>can be translated to:</p><pre><code>let args = cuts ~sep:&quot;,&quot; buffer in</code></pre><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty buffer.</p></dd></dl></div></div><div><div class="spec value" id="val-fields" class="anchored"><a href="#val-fields" class="anchor"></a><code><span class="keyword">val</span> fields : <span>?&#8288;empty:bool</span> <span>&#45;&gt;</span> <span>?&#8288;is_sep:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span></code></div><div><p><code>fields ~empty ~is_sep cs</code> is the list of (possibly empty) sub-buffers that are delimited by bytes for which <code>is_sep</code> is <code>true</code>. Empty sub-buffers are omitted in the list if <code>empty</code> is <code>false</code> (defaults to <code>true</code>). <code>is_sep c</code> if it's not define by the user is <code>true</code> iff <code>c</code> is an US-ASCII white space character, that is one of space <code>' '</code> (<code>0x20</code>), tab <code>'\t'</code> (<code>0x09</code>), newline <code>'\n'</code> (<code>0x0a</code>), vertical tab (<code>0x0b</code>), form feed (<code>0x0c</code>), carriage return <code>'\r'</code> (<code>0x0d</code>).</p></div></div><div><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> option</span></code></div><div><p><code>find ~rev sat cs</code> is the sub-buffer of <code>cs</code> (if any) that spans the first byte that satisfies <code>sat</code> in <code>cs</code> after position <code>start cs</code> (<code>rev</code> is <code>false</code>, default) or before <code>stop cs</code> (<code>rev</code> is <code>true</code>). <code>None</code> is returned if there is no matching byte in <code>s</code>.</p></div></div><div><div class="spec value" id="val-find_sub" class="anchored"><a href="#val-find_sub" class="anchor"></a><code><span class="keyword">val</span> find_sub : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>sub:<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> option</span></code></div><div><p><code>find_sub ~rev ~sub cs</code> is the sub-buffer of <code>cs</code> (if any) that spans the first match of <code>sub</code> in <code>cs</code> after position <code>start cs</code> (<code>rev</code> is <code>false</code>, default) or before <code>stop cs</code> (<code>rev</code> is <code>true</code>). Only bytes are compared and <code>sub</code> can be on a different base buffer. <code>None</code> is returned if there is no match of <code>sub</code> in <code>s</code>.</p></div></div><div><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>filter sat cs</code> is the buffer made of the bytes of <code>cs</code> that satisfy <code>sat</code>, in the same order.</p></div></div><div><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(char <span>&#45;&gt;</span> <span>char option</span>)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>filter_map f cs</code> is the buffer made of the bytes of <code>cs</code> as mapped by <code>f</code>, in the same order.</p></div></div><div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(char <span>&#45;&gt;</span> char)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map f cs</code> is <code>cs'</code> with <code>cs'.[i] = f cs.[i]</code> for all indices <code>i</code> of <code>cs</code>. <code>f</code> is invoked in increasing index order.</p></div></div><div><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>(int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map f cs</code> is <code>cs'</code> with <code>cs'.[i] = f i cs.[i]</code> for all indices <code>i</code> of <code>cs</code>. <code>f</code> is invoked in increasing index order.</p></div></div></div></body></html>