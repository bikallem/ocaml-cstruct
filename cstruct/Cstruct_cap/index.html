<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cstruct_cap (cstruct.Cstruct_cap)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">cstruct</a> &#x00BB; Cstruct_cap</nav><h1>Module <code>Cstruct_cap</code></h1></header><dl><dt class="spec type" id="type-rd"><a href="#type-rd" class="anchor"></a><code><span class="keyword">type</span> <span>'a rd</span></code><code> = &lt; rd : unit; .. &gt; <span class="keyword">as</span> 'a</code></dt><dd><p>Type of read capability.</p></dd></dl><dl><dt class="spec type" id="type-wr"><a href="#type-wr" class="anchor"></a><code><span class="keyword">type</span> <span>'a wr</span></code><code> = &lt; wr : unit; .. &gt; <span class="keyword">as</span> 'a</code></dt><dd><p>Type of write capability.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>Type of cstruct with capabilities <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer</code><code> = <span><span>(char, Stdlib.Bigarray.int8_unsigned_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt><dd><p>Type of buffer. A <a href="index.html#type-t"><code>t</code></a> is composed of an underlying buffer.</p></dd></dl><dl><dt class="spec type" id="type-rdwr"><a href="#type-rdwr" class="anchor"></a><code><span class="keyword">type</span> rdwr</code><code> = &lt; rd : unit; wr : unit; &gt;</code></dt><dd><p>Type of read-and-capability.</p></dd></dl><dl><dt class="spec type" id="type-ro"><a href="#type-ro" class="anchor"></a><code><span class="keyword">type</span> ro</code><code> = &lt; rd : unit; &gt;</code></dt><dd><p>Type of read-only capability.</p></dd></dl><dl><dt class="spec type" id="type-wo"><a href="#type-wo" class="anchor"></a><code><span class="keyword">type</span> wo</code><code> = &lt; wr : unit; &gt;</code></dt><dd><p>Type of write-only capability.</p></dd></dl><dl><dt class="spec type" id="type-uint8"><a href="#type-uint8" class="anchor"></a><code><span class="keyword">type</span> uint8</code><code> = int</code></dt><dd><p>8-bit unsigned integer.</p></dd></dl><dl><dt class="spec type" id="type-uint16"><a href="#type-uint16" class="anchor"></a><code><span class="keyword">type</span> uint16</code><code> = int</code></dt><dd><p>16-bit unsigned integer.</p></dd></dl><dl><dt class="spec type" id="type-uint32"><a href="#type-uint32" class="anchor"></a><code><span class="keyword">type</span> uint32</code><code> = int32</code></dt><dd><p>32-bit unsigned integer.</p></dd></dl><dl><dt class="spec type" id="type-uint64"><a href="#type-uint64" class="anchor"></a><code><span class="keyword">type</span> uint64</code><code> = int64</code></dt><dd><p>64-bit unsigned integer.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>create len</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of size <code>len</code>. with an offset of 0, filled with zero bytes.</p></dd></dl><dl><dt class="spec value" id="val-create_unsafe"><a href="#val-create_unsafe" class="anchor"></a><code><span class="keyword">val</span> create_unsafe : int <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>create_unsafe len</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of size <code>len</code> with an offset of 0.</p><p>Note that the returned cstruct will contain arbitrary data, likely including the contents of previously-deallocated cstructs.</p><p>Beware!</p><p>Forgetting to replace this data could cause your application to leak sensitive information.</p></dd></dl><dl><dt class="spec value" id="val-ro"><a href="#val-ro" class="anchor"></a><code><span class="keyword">val</span> ro : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-ro">ro</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>ro t</code> has <code>t</code> to be read-only then.</p></dd></dl><dl><dt class="spec value" id="val-wo"><a href="#val-wo" class="anchor"></a><code><span class="keyword">val</span> wo : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-wo">wo</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>wo t</code> has <code>t</code> to be write-only then.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_string ~off ~len s</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of <code>s</code> sliced on <code>off</code> (default is <code>0</code>) and of <code>len</code> (default is <code>String.length s</code>) length.</p></dd></dl><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-of_hex"><a href="#val-of_hex" class="anchor"></a><code><span class="keyword">val</span> of_hex : string <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_bytes ~off ~len x</code> is a fresh read-and-write <a href="index.html#type-t"><code>t</code></a> of <code>x</code> sliced on <code>off</code> (default is <code>0</code>) and of <code>len</code> (default is <code>Bytes.length x</code>) length.</p></dd></dl><dl><dt class="spec value" id="val-to_bigarray"><a href="#val-to_bigarray" class="anchor"></a><code><span class="keyword">val</span> to_bigarray : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a></code></dt><dd><p><code>to_bigarray t</code> converts <a href="index.html#type-t"><code>t</code></a> into a <a href="index.html#type-buffer"><code>buffer</code></a> Bigarray, using the Bigarray slicing to allocate a fresh <i>proxy</i> Bigarray that preserves sharing of the underlying buffer.</p><p>In other words:</p><pre><code class="ml">let t = Cstruct_cap.create 10 in
let b = Cstruct_cap.to_bigarray t in
Bigarray.Array1.set b 0 '\x42' ;
assert (Cstruct_cap.get_char t 0 = '\x42')</code></pre></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal a b</code> is <code>true</code> iff <code>a</code> and <code>b</code> correspond to the same sequence of bytes (it uses <code>memcmp</code> internally). Both need at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare a b</code> gives an unspecified total ordering over <a href="index.html#type-t"><code>t</code></a>. Both need at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-check_alignment"><a href="#val-check_alignment" class="anchor"></a><code><span class="keyword">val</span> check_alignment : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>check_alignment t alignment</code> is <code>true</code> if the first byte stored within <code>t</code> is at a memory address where <code>address mod alignment = 0</code>, <code>false</code> otherwise. The <code>mod</code> used has the C/OCaml semantic (which differs from Python). Typical uses are to check a buffer is aligned to a page or disk sector boundary. <code>t</code> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>alignment</code> is not a positive integer.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_char"><a href="#val-get_char" class="anchor"></a><code><span class="keyword">val</span> get_char : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get_char t off</code> returns the character contained in <code>t</code> at offset <code>off</code>. <code>t</code> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_uint8"><a href="#val-get_uint8" class="anchor"></a><code><span class="keyword">val</span> get_uint8 : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-uint8">uint8</a></code></dt><dd><p><code>get_uint8 t off</code> returns the byte contained in <code>t</code> at offset <code>off</code>. <code>t</code> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-set_char"><a href="#val-set_char" class="anchor"></a><code><span class="keyword">val</span> set_char : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_char t off c</code> sets the character contained in <code>t</code> at offset <code>off</code> to character <code>c</code>. <code>t</code> needs at least write capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-set_uint8"><a href="#val-set_uint8" class="anchor"></a><code><span class="keyword">val</span> set_uint8 : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-uint8">uint8</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_uint8 t off x</code> sets the byte contained in <code>t</code> at offset <code>off</code> to byte <code>x</code>. <code>t</code> needs at least write capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length (which can differ from underlying buffer length).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>sub t ~off ~len</code> returns a fresh <a href="index.html#type-t"><code>t</code></a> with the shared underlying buffer of <code>t</code> sliced on <code>off</code> and of <code>len</code> length. New <a href="index.html#type-t"><code>t</code></a> shares same capabilities than <code>t</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val</span> shift : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>shift t len</code> returns a fresh <a href="index.html#type-t"><code>t</code></a> with the shared underlying buffer of <code>t</code> shifted to <code>len</code> bytes. New <a href="index.html#type-t"><code>t</code></a> shares same capabilities than <code>t</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds <code>t</code> length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string ~off ~len t</code> is the string representation of the segment of <code>t</code> starting at <code>off</code> (default is <code>0</code>) of size <code>len</code> (default is <code>length t</code>). <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>off</code> and <code>len</code> does not designate a valid segment of <code>t</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>to_bytes ~off ~len t</code> is the bytes representation of the segment of <code>t</code> starting at <code>off</code> (default is <code>0</code>) of size <code>len</code> (default is <code>length t</code>). <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>off</code> and <code>len</code> do not designate a valid segment of <code>t</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to <code>dst</code>, starting at index <code>dst_off</code>. It works correctly even if <code>src</code> and <code>dst</code> have the same underlying <a href="index.html#type-buffer"><code>buffer</code></a>, and the <code>src</code> and <code>dst</code> intervals overlap. This function uses <code>memmove</code> internally.</p><p><code>src</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. <code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>. Both don't share capabilities.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid segment of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-blit_from_string"><a href="#val-blit_from_string" class="anchor"></a><code><span class="keyword">val</span> blit_from_string : string <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit_from_string src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to <code>dst</code>, starting at index <code>dst_off</code>. This function uses <code>memcpy</code> internally.</p><p><code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid sub-string of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-blit_from_bytes"><a href="#val-blit_from_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_from_bytes : bytes <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit_from_bytes src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to <code>dst</code>, starting at index <code>dst_off</code>. This uses <code>memcpy</code> internally.</p><p><code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid sub-sequence of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do no designate a valid segment of <code>dst</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-blit_to_bytes"><a href="#val-blit_to_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_to_bytes : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>src_off:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <span>dst_off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit_to_bytes src ~src_off dst ~dst_off ~len</code> copies <code>len</code> characters from <code>src</code>, starting at index <code>src_off</code>, to sequences <code>dst</code>, starting at index <code>dst_off</code>. <code>blit_to_bytes</code> uses <code>memcpy</code> internally.</p><p><code>src</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>src_off</code> and <code>len</code> do not designate a valid segment of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid sub-seuqnce of <code>dst</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-memset"><a href="#val-memset" class="anchor"></a><code><span class="keyword">val</span> memset : <span><span><span class="type-var">'a</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>memset t x</code> sets all bytes of <code>t</code> to <code>x land 0xff</code>. <code>t</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length t</code> return length of <code>t</code>. Note that this length is potentially smaller than the actual size of the underlying buffer, as the <a href="index.html#val-sub"><code>sub</code></a> function can construct a smaller view. <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>?&#8288;start:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>split ~start t len</code> is a tuple containing <a href="index.html#type-t"><code>t</code></a>s extracted from <code>t</code> at offset <code>start</code> (default is <code>0</code>) of length <code>len</code> as first element, and the rest of <code>t</code> as second element.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sart</code> exceeds the <code>t</code> length, or if there is a bounds violation of <code>t</code> via <code>len + start</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-printer of <a href="index.html#type-t"><code>t</code></a>. <a href="index.html#type-t"><code>t</code></a> needs at least read capability <a href="index.html#type-rd"><code>rd</code></a>.</p></dd></dl><div class="spec module" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-lenv"><a href="#val-lenv" class="anchor"></a><code><span class="keyword">val</span> lenv : <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>lenv vs</code> is the combined length of all <a href="index.html#type-t"><code>t</code></a> in <code>vs</code>. Each <a href="index.html#type-t"><code>t</code></a> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if computing the sum overflows.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copyv"><a href="#val-copyv" class="anchor"></a><code><span class="keyword">val</span> copyv : <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>copy vs</code> is the string representation of the concatenation of all <a href="index.html#type-t"><code>t</code></a> in <code>vss</code>. Each <a href="index.html#type-t"><code>t</code></a> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the length of the result would exceed <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fillv"><a href="#val-fillv" class="anchor"></a><code><span class="keyword">val</span> fillv : <span>src:<span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span></span> <span>&#45;&gt;</span> <span>dst:<span><span><span class="type-var">'b</span> <a href="index.html#type-wr">wr</a></span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> int * <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span></code></dt><dd><p><code>fillv ~src ~dst</code> copies from <code>src</code> to <code>dst</code> until <code>src</code> is exhausted or <code>dst</code> is full. It returns the number of bytes copied and the remaining data from <code>src</code>, if any. This is useful if you want to <i>bufferize</i> data into fixed-sized chunks. Each <a href="index.html#type-t"><code>t</code></a> of <code>src</code> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. <code>dst</code> needs at least write-capability <a href="index.html#type-wr"><code>wr</code></a>. Each <a href="index.html#type-t"><code>t</code></a> of <code>src</code> and dst don't share capabilities.</p></dd></dl><dl><dt class="spec type" id="type-iter"><a href="#type-iter" class="anchor"></a><code><span class="keyword">type</span> <span>'a iter</span></code><code> = unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Type of iterator.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int option</span>)</span> <span>&#45;&gt;</span> <span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'v</span>)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-iter">iter</a></span></code></dt><dd><p><code>iter lenf of_cstruct t</code> is an iterator over <code>t</code> that returns elements of size <code>lenf t</code> and type <code>of_cstruct t</code>. <code>t</code> needs at least read-capability <a href="index.html#type-rd"><code>rd</code></a> and <code>iter</code> keeps capabilities of <code>t</code> on <code>of_cstruct</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'x</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'x</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p><code>fold f iter acc</code> is <code>(f iterN accN ... (f iter acc)...)</code>.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>append a b</code> create a fresh <a href="index.html#type-t"><code>t</code></a> which is the concatenation of <code>a</code> and <code>b</code>. <code>a</code> and <code>b</code> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. Resulted <a href="index.html#type-t"><code>t</code></a> has read-and-write capability.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>concat vss</code> is the concatenation of all <a href="index.html#type-t"><code>t</code></a> in <code>vss</code>. Each <a href="index.html#type-t"><code>t</code></a> of <code>vss</code> need at least read-capability <a href="index.html#type-rd"><code>rd</code></a>. <code>concat</code> always creates a fresh <a href="index.html#type-t"><code>t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> <a href="index.html#type-rd">rd</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-rdwr">rdwr</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>rev t</code> is <code>t</code> in reverse order. The return value is a freshly allocated <a href="index.html#type-t"><code>t</code></a>, and <code>t</code> is not modified according <a href="index.html#type-rd"><code>rd</code></a> capability.</p></dd></dl></div></body></html>